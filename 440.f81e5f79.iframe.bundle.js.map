{"version":3,"file":"440.f81e5f79.iframe.bundle.js","mappings":";AAgDA;;AAMA;;;AAIA;;AAOA;;;AAOA;AACA;;;;;AAZA;;AA4BA;AAEA;AAIA;;AAIA;;;;;;AA1EA;;;;;;AC0BA;;;AAGA;AACA;;;AAKA;;;;;ACmEA;;;AAIA;;;;;;;;AAQA;AACA;;;AAGA;;;AAIA;;;;;;AA1BA;;AAkHA;;;;AAIA;AACA;AACA;AACA;;;AAIA;AAKA;;;;AAKA;AACA;;;;AAMA;;;;;AAKA;AACA;AACA;AAGA;;;;;AAKA;;;;;AAQA;;;AAIA;AACA;;AAEA;;;;;AAOA;AACA;AACA;;;;;;;AAQA;;ACnPA;;;AAGA;;AAGA;;;;;AAMA;;AAEA;;;;AAMA;;AAQA;;AAGA;AAEA;;;;AAxEA;ACQA;AACA;AAGA;AACA;;;;AAIA;;;AAIA;;;;ACaA;;;AAKA;;AAGA;;;AAgBA;;AAEA;;;;;;;;AAQA;;AAvBA;;;;;AAMA;;AAsBA;;;;;;;;;;;;;;;AAoBA;;;;;;;AAUA;AAIA;AAKA;;;;;;;;;;ACvFA;;;;;AAYA;AAIA;AAIA;;;;;AAwBA;;;;ACvFA;;;;;;;;;;ACuHA;AAEA;AACA;AAEA;AAIA;AAGA;;;AAGA;;AAKA;;;;;;AAOA;;AAEA;;;;;;;;;AAgBA;AACA;;AAEA;;;;AAIA;;;AAIA;;;;;;;;AAeA;;;;;AC/IA;;AAGA;AACA;AACA;AAGA;AAEA;AAGA","sources":["webpack://@holochain-open-dev/profiles-dev/../../src/elements/agent-avatar.ts","webpack://@holochain-open-dev/profiles-dev/../../src/elements/create-profile.ts","webpack://@holochain-open-dev/profiles-dev/../../src/elements/edit-profile.ts","webpack://@holochain-open-dev/profiles-dev/../../src/elements/list-profiles.ts","webpack://@holochain-open-dev/profiles-dev/../../src/elements/my-profile.ts","webpack://@holochain-open-dev/profiles-dev/../../src/elements/profile-detail.ts","webpack://@holochain-open-dev/profiles-dev/../../src/elements/profile-prompt.ts","webpack://@holochain-open-dev/profiles-dev/../../src/elements/profiles-context.ts","webpack://@holochain-open-dev/profiles-dev/../../src/elements/search-agent.ts","webpack://@holochain-open-dev/profiles-dev/../../src/elements/update-profile.ts"],"sourcesContent":["import { consume } from \"@lit-labs/context\";\nimport { HoloIdenticon, hashProperty } from \"@holochain-open-dev/elements\";\nimport { ScopedElementsMixin } from \"@open-wc/scoped-elements\";\nimport { css, html, LitElement } from \"lit\";\nimport { state, property } from \"lit/decorators.js\";\nimport { styleMap } from \"lit-html/directives/style-map.js\";\nimport { SlAvatar, SlSkeleton } from \"@scoped-elements/shoelace\";\nimport { StoreSubscriber } from \"lit-svelte-stores\";\nimport { AgentPubKey } from \"@holochain/client\";\nimport { Icon } from \"@scoped-elements/material-web\";\nimport { localized } from \"@lit/localize\";\n\nimport { profilesStoreContext } from \"../context\";\nimport { ProfilesStore } from \"../profiles-store\";\nimport { sharedStyles } from \"./utils/shared-styles\";\nimport { Profile } from \"../types\";\n\n@localized()\nexport class AgentAvatar extends ScopedElementsMixin(LitElement) {\n  /** Public properties */\n\n  /**\n   * REQUIRED. The public key identifying the agent whose profile is going to be shown.\n   */\n  @property(hashProperty(\"agent-pub-key\"))\n  agentPubKey!: AgentPubKey;\n\n  /**\n   * Size of the avatar image in pixels.\n   */\n  @property({ type: Number })\n  size = 32;\n\n  /** Dependencies */\n\n  /**\n   * @internal\n   */\n  @consume({ context: profilesStoreContext, subscribe: true })\n  @state()\n  _store!: ProfilesStore;\n\n  private _agentProfile = new StoreSubscriber(this, () =>\n    this._store.agentsProfiles.get(this.agentPubKey)\n  );\n\n  renderIdenticon() {\n    return html` <div\n      style=${styleMap({\n        position: \"relative\",\n        height: `${this.size}px`,\n        width: `${this.size}px`,\n      })}\n    >\n      <holo-identicon .hash=${this.agentPubKey} .size=${this.size}>\n      </holo-identicon>\n      <div class=\"badge\"><slot name=\"badge\"></slot></div>\n    </div>`;\n  }\n\n  renderProfile(profile: Profile | undefined) {\n    if (!profile || !profile.fields.avatar) return this.renderIdenticon();\n\n    return html`\n      <div\n        style=${styleMap({\n          position: \"relative\",\n          height: `${this.size}px`,\n          width: `${this.size}px`,\n        })}\n      >\n        <sl-avatar\n          .image=${profile.fields.avatar}\n          style=\"--size: ${this.size}px;\"\n        >\n        </sl-avatar>\n        <div class=\"badge\"><slot name=\"badge\"></slot></div>\n      </div>\n    `;\n  }\n\n  render() {\n    if (this._store.config.avatarMode === \"identicon\")\n      return this.renderIdenticon();\n\n    switch (this._agentProfile.value.status) {\n      case \"pending\":\n        return html`<sl-skeleton\n          effect=\"pulse\"\n          style=\"height: ${this.size}px; width: ${this.size}px\"\n        ></sl-skeleton>`;\n      case \"complete\":\n        return this.renderProfile(this._agentProfile.value.value);\n      case \"error\":\n        return html`<mwc-icon\n          style=\"height: ${this.size}px; width: ${this.size}px\"\n          >error</mwc-icon\n        >`;\n    }\n  }\n\n  /**\n   * @ignore\n   */\n  static get scopedElements() {\n    return {\n      \"holo-identicon\": HoloIdenticon,\n      \"sl-avatar\": SlAvatar,\n      \"sl-skeleton\": SlSkeleton,\n      \"mwc-icon\": Icon,\n    };\n  }\n\n  static styles = [\n    sharedStyles,\n    css`\n      .badge {\n        position: absolute;\n        right: 0;\n        bottom: 0;\n      }\n    `,\n  ];\n}\n","import { html, LitElement } from \"lit\";\nimport { state } from \"lit/decorators.js\";\nimport { consume } from \"@lit-labs/context\";\nimport { ScopedElementsMixin } from \"@open-wc/scoped-elements\";\nimport { Card } from \"@scoped-elements/material-web\";\n\nimport { sharedStyles } from \"./utils/shared-styles\";\nimport { ProfilesStore } from \"../profiles-store\";\nimport { profilesStoreContext } from \"../context\";\nimport { EditProfile } from \"./edit-profile\";\nimport { Profile } from \"../types\";\nimport { localized, msg } from \"@lit/localize\";\n\n/**\n * A custom element that fires event on value change.\n *\n * @element create-profile\n * @fires profile-created - Fired after the profile has been created. Detail will have this shape: { profile: { nickname, fields } }\n */\n@localized()\nexport class CreateProfile extends ScopedElementsMixin(LitElement) {\n  /**\n   * @internal\n   */\n  @consume({ context: profilesStoreContext, subscribe: true })\n  @state()\n  _store!: ProfilesStore;\n\n  /** Private properties */\n\n  async createProfile(profile: Profile) {\n    await this._store.client.createProfile(profile);\n\n    this.dispatchEvent(\n      new CustomEvent(\"profile-created\", {\n        detail: {\n          profile,\n        },\n        bubbles: true,\n        composed: true,\n      })\n    );\n  }\n\n  render() {\n    return html`\n      <mwc-card>\n        <div class=\"column\" style=\"margin: 16px;\">\n          <span\n            class=\"title\"\n            style=\"margin-bottom: 24px; align-self: flex-start\"\n            >${msg(\"Create Profile\")}</span\n          >\n          <edit-profile\n            .saveProfileLabel=${msg(\"Create Profile\")}\n            @save-profile=${(e: CustomEvent) =>\n              this.createProfile(e.detail.profile)}\n          ></edit-profile></div\n      ></mwc-card>\n    `;\n  }\n\n  /**\n   * @ignore\n   */\n  static get scopedElements() {\n    return {\n      \"edit-profile\": EditProfile,\n      \"mwc-card\": Card,\n    };\n  }\n  static get styles() {\n    return [sharedStyles];\n  }\n}\n","import { ScopedElementsMixin } from \"@open-wc/scoped-elements\";\nimport {\n  Button,\n  Fab,\n  IconButton,\n  TextField,\n} from \"@scoped-elements/material-web\";\nimport { SlAvatar } from \"@scoped-elements/shoelace\";\nimport { html, LitElement } from \"lit\";\nimport { property, query, state } from \"lit/decorators.js\";\nimport { localized, msg, str } from \"@lit/localize\";\nimport { consume } from \"@lit-labs/context\";\n\nimport { ProfilesStore } from \"../profiles-store\";\nimport { profilesStoreContext } from \"../context\";\nimport { Profile } from \"../types\";\nimport { resizeAndExport } from \"./utils/image\";\nimport { sharedStyles } from \"./utils/shared-styles\";\n\n/**\n * @element edit-profile\n * @fires save-profile - Fired when the save profile button is clicked\n */\n@localized()\nexport class EditProfile extends ScopedElementsMixin(LitElement) {\n  /**\n   * The profile to be edited.\n   */\n  @property({ type: Object })\n  profile: Profile | undefined;\n\n  /**\n   * Label for the save profile button.\n   */\n  @property({ type: String, attribute: \"save-profile-label\" })\n  saveProfileLabel: string | undefined;\n\n  /** Dependencies */\n\n  /**\n   * @internal\n   */\n  @consume({ context: profilesStoreContext, subscribe: true })\n  @state()\n  _store!: ProfilesStore;\n\n  @property({ type: Boolean })\n  allowCancel = false;\n\n  /** Private properties */\n\n  /**\n   * @internal\n   */\n  @query(\"#nickname-field\")\n  private _nicknameField!: TextField;\n\n  /**\n   * @internal\n   */\n  private _existingUsernames: { [key: string]: boolean } = {};\n\n  /**\n   * @internal\n   */\n  @query(\"#avatar-file-picker\")\n  private _avatarFilePicker!: HTMLInputElement;\n\n  /**\n   * @internal\n   */\n  @state()\n  private _avatar: string | undefined;\n\n  firstUpdated() {\n    this._avatar = this.profile?.fields[\"avatar\"];\n\n    this._nicknameField.validityTransform = (newValue: string) => {\n      this.requestUpdate();\n      if (newValue.length < this._store.config.minNicknameLength) {\n        this._nicknameField.setCustomValidity(msg(`Nickname is too short`));\n        return {\n          valid: false,\n        };\n      } else if (this._existingUsernames[newValue]) {\n        this._nicknameField.setCustomValidity(\n          msg(\"This nickname already exists\")\n        );\n        return { valid: false };\n      }\n\n      return {\n        valid: true,\n      };\n    };\n  }\n\n  onAvatarUploaded() {\n    if (this._avatarFilePicker.files && this._avatarFilePicker.files[0]) {\n      const reader = new FileReader();\n      reader.onload = (e) => {\n        const img = new Image();\n        img.crossOrigin = \"anonymous\";\n        img.onload = () => {\n          this._avatar = resizeAndExport(img);\n          this._avatarFilePicker.value = \"\";\n        };\n        img.src = e.target?.result as string;\n      };\n      reader.readAsDataURL(this._avatarFilePicker.files[0]);\n    }\n  }\n\n  avatarMode() {\n    return (\n      this._store.config.avatarMode === \"avatar-required\" ||\n      this._store.config.avatarMode === \"avatar-optional\"\n    );\n  }\n\n  renderAvatar() {\n    if (!this.avatarMode()) return html``;\n    return html`\n      <div\n        style=\"width: 80px; height: 80px; justify-content: center;\"\n        class=\"row\"\n      >\n        ${this._avatar\n          ? html`\n              <div class=\"column\" style=\"align-items: center; \">\n                <sl-avatar\n                  image=\"${this._avatar}\"\n                  alt=\"Avatar\"\n                  style=\"margin-bottom: 4px; --size: 3.5rem;\"\n                  initials=\"\"\n                ></sl-avatar>\n                <span\n                  class=\"placeholder label\"\n                  style=\"cursor: pointer;   text-decoration: underline;\"\n                  @click=${() => (this._avatar = undefined)}\n                  >${msg(\"Clear\")}</span\n                >\n              </div>\n            `\n          : html` <div class=\"column\" style=\"align-items: center;\">\n              <mwc-fab\n                icon=\"add\"\n                @click=${() => this._avatarFilePicker.click()}\n                style=\"margin-bottom: 4px;\"\n              ></mwc-fab>\n              <span class=\"placeholder label\">Avatar</span>\n            </div>`}\n      </div>\n    `;\n  }\n\n  shouldSaveButtonBeEnabled() {\n    if (!this._nicknameField) return false;\n    if (!this._nicknameField.validity.valid) return false;\n    if (this._store.config.avatarMode === \"avatar-required\" && !this._avatar)\n      return false;\n    if (\n      Object.values(this.getAdditionalTextFields()).find(\n        (t) => !t.validity.valid\n      )\n    )\n      return false;\n\n    return true;\n  }\n\n  textfieldToFieldId(field: TextField): string {\n    return field.id.split(\"-\")[2];\n  }\n\n  getAdditionalFieldsValues(): Record<string, string> {\n    const textfields = this.getAdditionalTextFields();\n\n    const values: Record<string, string> = {};\n    for (const [id, textfield] of Object.entries(textfields)) {\n      values[id] = textfield.value;\n    }\n\n    return values;\n  }\n\n  getAdditionalTextFields(): Record<string, TextField> {\n    const textfields = Array.from(\n      this.shadowRoot!.querySelectorAll(\"mwc-textfield\")\n    ).filter((f) => f.id !== \"nickname-field\") as TextField[];\n\n    const fields: Record<string, TextField> = {};\n    for (const field of textfields) {\n      const id = this.textfieldToFieldId(field);\n      fields[id] = field;\n    }\n    return fields;\n  }\n\n  fireSaveProfile() {\n    const nickname = this._nicknameField.value;\n\n    const fields: Record<string, string> = this.getAdditionalFieldsValues();\n    if (this._avatar) {\n      fields[\"avatar\"] = this._avatar;\n    }\n\n    const profile: Profile = {\n      fields,\n      nickname,\n    };\n\n    this.dispatchEvent(\n      new CustomEvent(\"save-profile\", {\n        detail: {\n          profile,\n        },\n        bubbles: true,\n        composed: true,\n      })\n    );\n  }\n\n  fireCancel() {\n    this.dispatchEvent(\n      new CustomEvent(\"cancel-edit-profile\", {\n        bubbles: true,\n        composed: true,\n      })\n    );\n  }\n\n  renderField(fieldName: string) {\n    return html`\n      <mwc-textfield\n        id=\"profile-field-${fieldName}\"\n        outlined\n        required\n        autoValidate\n        .validationMessage=${msg(\"This field is required\")}\n        .label=${fieldName}\n        .value=${this.profile?.fields[fieldName] || \"\"}\n        @input=${() => this.requestUpdate()}\n        style=\"margin-top: 8px;\"\n      ></mwc-textfield>\n    `;\n  }\n\n  render() {\n    return html`\n      ${\n        this.avatarMode()\n          ? html`<input\n              type=\"file\"\n              id=\"avatar-file-picker\"\n              style=\"display: none;\"\n              @change=${this.onAvatarUploaded}\n            />`\n          : html``\n      }\n        <div class=\"column\">\n\n          <div class=\"row\" style=\"justify-content: center; margin-bottom: 8px; align-self: start;\" >\n            ${this.renderAvatar()}\n\n            <mwc-textfield\n              id=\"nickname-field\"\n              outlined\n              .label=${msg(\"Nickname\")}\n              .value=${this.profile?.nickname || \"\"}\n              .helper=${msg(\n                str`Min. ${this._store.config.minNicknameLength} characters`\n              )}\n              @input=${() => this._nicknameField.reportValidity()}\n              style=\"margin-left: 8px;\"\n            ></mwc-textfield>\n          </div>\n\n          ${this._store.config.additionalFields.map((field) =>\n            this.renderField(field)\n          )}\n\n\n          <div class=\"row\" style=\"margin-top: 8px;\">\n\n            ${\n              this.allowCancel\n                ? html`\n                    <mwc-button\n                      style=\"flex: 1; margin-right: 6px;\"\n                      .label=${\"Cancel\"}\n                      @click=${() => this.fireCancel()}\n                    ></mwc-button>\n                  `\n                : html``\n            }\n\n            <mwc-button\n              style=\"flex: 1;\"\n              raised\n              .disabled=${!this.shouldSaveButtonBeEnabled()}\n              .label=${this.saveProfileLabel ?? msg(\"Save Profile\")}\n              @click=${() => this.fireSaveProfile()}\n            ></mwc-button>\n\n          </div>\n\n        </div>\n      </mwc-card>\n    `;\n  }\n\n  /**\n   * @ignore\n   */\n  static get scopedElements() {\n    return {\n      \"mwc-textfield\": TextField,\n      \"mwc-button\": Button,\n      \"mwc-fab\": Fab,\n      \"mwc-icon-button\": IconButton,\n      \"sl-avatar\": SlAvatar,\n    };\n  }\n\n  static styles = [sharedStyles];\n}\n","import { css, html, LitElement } from \"lit\";\nimport { AgentPubKey } from \"@holochain/client\";\nimport { state } from \"lit/decorators.js\";\nimport { ScopedElementsMixin } from \"@open-wc/scoped-elements\";\nimport { consume } from \"@lit-labs/context\";\nimport {\n  CircularProgress,\n  ListItem,\n  List,\n} from \"@scoped-elements/material-web\";\nimport { StoreSubscriber } from \"lit-svelte-stores\";\n\nimport { sharedStyles } from \"./utils/shared-styles\";\nimport { ProfilesStore } from \"../profiles-store\";\nimport { profilesStoreContext } from \"../context\";\nimport { AgentAvatar } from \"./agent-avatar\";\nimport { Profile } from \"../types\";\n\n/**\n * @element list-profiles\n * @fires agent-selected - Fired when the user selects an agent from the list. Detail will have this shape: { agentPubKey: <AGENT_PUB_KEY as Uint8Array> }\n */\nexport class ListProfiles extends ScopedElementsMixin(LitElement) {\n  /**\n   * @internal\n   */\n  @consume({ context: profilesStoreContext, subscribe: true })\n  @state()\n  _store!: ProfilesStore;\n\n  /** Private properties */\n\n  /**\n   * @internal\n   */\n  private _allProfiles = new StoreSubscriber(\n    this,\n    () => this._store.allProfiles\n  );\n\n  initials(nickname: string): string {\n    return nickname\n      .split(\" \")\n      .map((name) => name[0])\n      .join(\"\");\n  }\n\n  fireAgentSelected(agentPubKey: AgentPubKey) {\n    if (agentPubKey) {\n      this.dispatchEvent(\n        new CustomEvent(\"agent-selected\", {\n          bubbles: true,\n          composed: true,\n          detail: {\n            agentPubKey,\n          },\n        })\n      );\n    }\n  }\n\n  renderList(profiles: ReadonlyMap<AgentPubKey, Profile>) {\n    if (profiles.size === 0)\n      return html`<mwc-list-item\n        >There are no created profiles yet</mwc-list-item\n      >`;\n\n    return html`\n      <mwc-list\n        style=\"min-width: 80px; flex: 1;\"\n        @selected=${(e: CustomEvent) =>\n          this.fireAgentSelected(Array.from(profiles.keys())[e.detail.index])}\n      >\n        ${Array.from(profiles.entries()).map(\n          ([agent_pub_key, profile]) => html`\n            <mwc-list-item\n              graphic=\"avatar\"\n              style=\"--mdc-list-item-graphic-size: 32px;\"\n            >\n              <agent-avatar slot=\"graphic\" .agentPubKey=${agent_pub_key}>\n              </agent-avatar>\n              <span>${profile.nickname}</span>\n            </mwc-list-item>\n          `\n        )}\n      </mwc-list>\n    `;\n  }\n\n  render() {\n    switch (this._allProfiles.value.status) {\n      case \"pending\":\n        return html`<div class=\"fill center-content\">\n          <mwc-circular-progress indeterminate></mwc-circular-progress>\n        </div>`;\n      case \"error\":\n        return html`<span\n          >There was an error loading the profiles:\n          ${this._allProfiles.value.error}<span></span\n        ></span>`;\n      case \"complete\":\n        return this.renderList(this._allProfiles.value.value);\n    }\n  }\n\n  static styles = [\n    sharedStyles,\n    css`\n      :host {\n        display: flex;\n      }\n    `,\n  ];\n\n  /**\n   * @ignore\n   */\n  static get scopedElements() {\n    return {\n      \"agent-avatar\": AgentAvatar,\n      \"mwc-circular-progress\": CircularProgress,\n      \"mwc-list\": List,\n      \"mwc-list-item\": ListItem,\n    };\n  }\n}\n","import { consume } from \"@lit-labs/context\";\nimport { ScopedElementsMixin } from \"@open-wc/scoped-elements\";\nimport { html, LitElement } from \"lit\";\nimport { state } from \"lit/decorators.js\";\n\nimport { profilesStoreContext } from \"../context\";\nimport { ProfilesStore } from \"../profiles-store\";\nimport { sharedStyles } from \"./utils/shared-styles\";\nimport { ProfileDetail } from \"./profile-detail\";\nimport { IconButton } from \"@scoped-elements/material-web\";\nimport { UpdateProfile } from \"./update-profile\";\n\n/**\n * @element profile-detail\n */\nexport class MyProfile extends ScopedElementsMixin(LitElement) {\n  /** Dependencies */\n\n  /**\n   * @internal\n   */\n  @consume({ context: profilesStoreContext, subscribe: true })\n  @state()\n  _store!: ProfilesStore;\n\n  /** Private properties */\n\n  /**\n   * @internal\n   */\n  @state()\n  private _editing = false;\n\n  render() {\n    if (this._editing)\n      return html`<update-profile\n        @profile-updated=${() => (this._editing = false)}\n        @cancel-edit-profile=${() => (this._editing = false)}\n      ></update-profile>`;\n\n    return html`\n      <profile-detail .agentPubKey=${this._store.client.client.myPubKey}>\n        <mwc-icon-button\n          slot=\"action\"\n          icon=\"edit\"\n          @click=${() => (this._editing = true)}\n        ></mwc-icon-button>\n      </profile-detail>\n    `;\n  }\n\n  /**\n   * @ignore\n   */\n  static get scopedElements() {\n    return {\n      \"mwc-icon-button\": IconButton,\n      \"profile-detail\": ProfileDetail,\n      \"update-profile\": UpdateProfile,\n    };\n  }\n\n  static styles = [sharedStyles];\n}\n","import { consume } from \"@lit-labs/context\";\nimport { AgentPubKey } from \"@holochain/client\";\nimport { ScopedElementsMixin } from \"@open-wc/scoped-elements\";\nimport { html, LitElement } from \"lit\";\nimport { StoreSubscriber } from \"lit-svelte-stores\";\nimport { state, property } from \"lit/decorators.js\";\nimport { SlSkeleton } from \"@scoped-elements/shoelace\";\nimport { msg } from \"@lit/localize\";\nimport { hashProperty } from \"@holochain-open-dev/elements\";\n\nimport { profilesStoreContext } from \"../context\";\nimport { ProfilesStore } from \"../profiles-store\";\nimport { sharedStyles } from \"./utils/shared-styles\";\nimport { AgentAvatar } from \"./agent-avatar\";\nimport { Profile } from \"../types\";\nimport { camelCase } from \"lodash-es\";\n\n/**\n * @element profile-detail\n */\nexport class ProfileDetail extends ScopedElementsMixin(LitElement) {\n  /** Public properties */\n\n  /**\n   * REQUIRED. Public key identifying the agent for which the profile should be shown\n   */\n  @property(hashProperty(\"agent-pub-key\"))\n  agentPubKey!: AgentPubKey;\n\n  /**\n   * @internal\n   */\n  @consume({ context: profilesStoreContext, subscribe: true })\n  @state()\n  _store!: ProfilesStore;\n\n  /** Private properties */\n\n  /**\n   * @internal\n   */\n  private _agentProfile = new StoreSubscriber(this, () =>\n    this._store.agentsProfiles.get(this.agentPubKey)\n  );\n\n  getAdditionalFields(profile: Profile): Record<string, string> {\n    const fields: Record<string, string> = {};\n\n    for (const [key, value] of Object.entries(profile.fields)) {\n      if (key !== \"avatar\") {\n        fields[key] = value;\n      }\n    }\n\n    return fields;\n  }\n\n  renderAdditionalField(fieldId: string, fieldValue: string) {\n    return html`\n      <div class=\"row\" style=\"margin-top: 16px\">\n        <span style=\"margin-right: 16px; \">\n          <strong\n            >${fieldId.substring(0, 1).toUpperCase()}${fieldId.substring(\n              1\n            )}</strong\n          ></span\n        >\n        <span>${fieldValue}</span>\n      </div>\n    `;\n  }\n\n  renderProfile(profile: Profile | undefined) {\n    if (!profile)\n      return html`<div\n        class=\"column\"\n        style=\"align-items: center; justify-content: center; flex: 1;\"\n      >\n        <span class=\"placeholder\"\n          >${msg(\"This agent hasn't created a profile yet\")}</span\n        >\n      </div>`;\n\n    return html`\n      <div class=\"column\">\n        <div class=\"row\" style=\"align-items: center\">\n          <agent-avatar .agentPubKey=${this.agentPubKey}></agent-avatar>\n          <span style=\"font-size: 16px; margin-left: 8px;\"\n            >${profile.nickname}</span\n          >\n\n          <span style=\"flex: 1\"></span>\n\n          <slot name=\"action\"></slot>\n        </div>\n\n        ${Object.entries(this.getAdditionalFields(profile)).map(\n          ([key, value]) => this.renderAdditionalField(key, value)\n        )}\n      </div>\n    `;\n  }\n\n  render() {\n    switch (this._agentProfile.value.status) {\n      case \"pending\":\n        return html`\n          <div class=\"column\">\n            <div class=\"row\" style=\"align-items: center\">\n              <sl-skeleton\n                effect=\"pulse\"\n                style=\"height: 32px; width: 32px; border-radius: 50%;\"\n              ></sl-skeleton>\n              <div>\n                <sl-skeleton\n                  effect=\"pulse\"\n                  style=\"width: 122px; margin-left: 8px;\"\n                ></sl-skeleton>\n              </div>\n            </div>\n\n            ${this._store.config.additionalFields.map(\n              () => html`\n                <sl-skeleton\n                  effect=\"pulse\"\n                  style=\"width: 200px; margin-top: 16px;\"\n                ></sl-skeleton>\n              `\n            )}\n          </div>\n        `;\n      case \"complete\":\n        return this.renderProfile(this._agentProfile.value.value);\n      case \"error\":\n        return html`<span\n          >${msg(\n            \"There was an error while fetching the profile for this agent\"\n          )}</span\n        >`;\n    }\n  }\n\n  /**\n   * @ignore\n   */\n  static get scopedElements() {\n    return {\n      \"agent-avatar\": AgentAvatar,\n      \"sl-skeleton\": SlSkeleton,\n    };\n  }\n\n  static styles = [sharedStyles];\n}\n","import { css, html, LitElement } from \"lit\";\nimport { state } from \"lit/decorators.js\";\n\nimport {\n  Button,\n  CircularProgress,\n  TextField,\n} from \"@scoped-elements/material-web\";\nimport { ScopedElementsMixin } from \"@open-wc/scoped-elements\";\nimport { localized, msg } from \"@lit/localize\";\nimport { consume } from \"@lit-labs/context\";\nimport { StoreSubscriber } from \"lit-svelte-stores\";\n\nimport { sharedStyles } from \"./utils/shared-styles\";\nimport { CreateProfile } from \"./create-profile\";\nimport { ProfilesStore } from \"../profiles-store\";\nimport { profilesStoreContext } from \"../context\";\nimport { Profile } from \"../types\";\n\n/**\n * @element profile-prompt\n * @slot hero - Will be displayed above the create-profile form when the user is prompted with it\n */\n@localized()\nexport class ProfilePrompt extends ScopedElementsMixin(LitElement) {\n  /**\n   * @internal\n   */\n  @consume({ context: profilesStoreContext, subscribe: true })\n  @state()\n  _store!: ProfilesStore;\n\n  /** Private properties */\n\n  /**\n   * @internal\n   */\n  private _myProfile = new StoreSubscriber(this, () => this._store.myProfile);\n\n  renderPrompt(myProfile: Profile | undefined) {\n    if (myProfile) return html`<slot></slot>`;\n\n    return html`\n      <div\n        class=\"column\"\n        style=\"align-items: center; justify-content: center; flex: 1; padding-bottom: 10px;\"\n      >\n        <div class=\"column\" style=\"align-items: center;\">\n          <slot name=\"hero\"></slot>\n          <create-profile></create-profile>\n        </div>\n      </div>\n    `;\n  }\n\n  render() {\n    console.log(this._myProfile.value);\n    switch (this._myProfile.value.status) {\n      case \"pending\":\n        return html` <div\n          class=\"column\"\n          style=\"align-items: center; justify-content: center; flex: 1;\"\n        >\n          <mwc-circular-progress indeterminate></mwc-circular-progress>\n        </div>`;\n      case \"complete\":\n        return this.renderPrompt(this._myProfile.value.value);\n      case \"error\":\n        return html`<span\n          >${msg(\"There was an error while fetching your profile: \")}${this\n            ._myProfile.value.error}</span\n        >`;\n    }\n  }\n\n  /**\n   * @ignore\n   */\n  static get scopedElements() {\n    return {\n      \"mwc-textfield\": TextField,\n      \"mwc-button\": Button,\n      \"mwc-circular-progress\": CircularProgress,\n      \"create-profile\": CreateProfile,\n    };\n  }\n\n  static get styles() {\n    return [\n      sharedStyles,\n      css`\n        :host {\n          display: flex;\n          flex: 1;\n        }\n      `,\n    ];\n  }\n}\n","import { css, html, LitElement } from \"lit\";\nimport { provide } from \"@lit-labs/context\";\nimport { property } from \"lit/decorators.js\";\n\nimport { profilesStoreContext } from \"../context\";\nimport { ProfilesStore } from \"../profiles-store\";\n\nexport class ProfilesContext extends LitElement {\n  @provide({ context: profilesStoreContext })\n  @property({ type: Object })\n  store!: ProfilesStore;\n\n  render() {\n    return html`<slot></slot>`;\n  }\n\n  static styles = css`\n    :host {\n      display: contents;\n    }\n  `;\n}\n","import { property, state, query } from \"lit/decorators.js\";\nimport { css, html, LitElement } from \"lit\";\nimport {\n  MenuSurface,\n  List,\n  ListItem,\n  TextField,\n} from \"@scoped-elements/material-web\";\nimport { consume } from \"@lit-labs/context\";\nimport { ScopedElementsMixin } from \"@open-wc/scoped-elements\";\nimport { msg } from \"@lit/localize\";\nimport { AgentPubKey } from \"@holochain/client\";\nimport { AsyncStatus } from \"@holochain-open-dev/stores\";\nimport { SlSkeleton } from \"@scoped-elements/shoelace\";\nimport { StoreSubscriber } from \"lit-svelte-stores\";\n\nimport { Profile } from \"../types\";\nimport { sharedStyles } from \"./utils/shared-styles\";\nimport { ProfilesStore } from \"../profiles-store\";\nimport { profilesStoreContext } from \"../context\";\nimport { AgentAvatar } from \"./agent-avatar\";\n\n/**\n * @element search-agent\n * @fires agent-selected - Fired when the user selects some agent. Detail will have this shape: { agentPubKey: HoloHash }\n */\nexport class SearchAgent extends ScopedElementsMixin(LitElement) {\n  /** Public attributes */\n\n  /**\n   * Whether to clear the field when an agent is selected.\n   * @attr clear-on-select\n   */\n  @property({ type: Boolean, attribute: \"clear-on-select\" })\n  clearOnSelect = false;\n\n  /**\n   * Whether to include my own agent as a possible agent to select.\n   * @attr include-myself\n   */\n  @property({ type: Boolean, attribute: \"include-myself\" })\n  includeMyself = false;\n\n  /**\n   * Label for the agent searching field.\n   * @attr field-label\n   */\n  @property({ type: String, attribute: \"field-label\" })\n  fieldLabel!: string;\n\n  /**\n   * @internal\n   */\n  @consume({ context: profilesStoreContext, subscribe: true })\n  @state()\n  _store!: ProfilesStore;\n\n  /**\n   * @internal\n   */\n  @state()\n  private _searchProfiles:\n    | StoreSubscriber<AsyncStatus<ReadonlyMap<AgentPubKey, Profile>>>\n    | undefined;\n\n  /**\n   * @internal\n   */\n  @query(\"#textfield\")\n  private _textField!: TextField;\n\n  /**\n   * @internal\n   */\n  @query(\"#overlay\")\n  private _overlay!: MenuSurface;\n\n  firstUpdated() {\n    this.addEventListener(\"blur\", () => this._overlay.close());\n  }\n\n  onFilterChange() {\n    if (this._textField.value.length < 3) {\n      this._searchProfiles = undefined;\n      return;\n    }\n\n    this._overlay.show();\n    const store = this._store.searchProfiles(this._textField.value);\n    this._searchProfiles = new StoreSubscriber(this, () => store);\n  }\n\n  onUsernameSelected([agentPubKey, profile]: [AgentPubKey, Profile]) {\n    this.dispatchEvent(\n      new CustomEvent(\"agent-selected\", {\n        detail: {\n          agentPubKey,\n        },\n      })\n    );\n\n    // If the consumer says so, clear the field\n    if (this.clearOnSelect) {\n      this._textField.value = \"\";\n      this._searchProfiles = undefined;\n    } else {\n      this._textField.value = profile.nickname;\n    }\n    this._overlay.close();\n  }\n\n  renderAgentList() {\n    if (this._searchProfiles === undefined) return html``;\n    switch (this._searchProfiles.value.status) {\n      case \"pending\":\n        return [0, 0, 0].map(\n          () =>\n            html`<div class=\"row\" style=\"align-items: center; width: 150px\">\n              <sl-skeleton\n                effect=\"sheen\"\n                style=\"height: 32px; width: 32px; border-radius: 50%; margin: 8px\"\n              ></sl-skeleton\n              ><sl-skeleton\n                effect=\"sheen\"\n                style=\"flex: 1; margin: 8px; border-radius: 12px\"\n              >\n              </sl-skeleton>\n            </div>`\n        );\n      case \"error\":\n        return html`<span\n          >${msg(\"There was an error while fetching the agents:\")}\n          ${this._searchProfiles.value.error}</span\n        >`;\n      case \"complete\": {\n        const agents = this._searchProfiles.value.value;\n        if (agents.size === 0)\n          return html`<mwc-list-item\n            >${msg(\"No agents match the filter\")}</mwc-list-item\n          >`;\n\n        return html`\n          <mwc-list\n            style=\"min-width: 80px;\"\n            @selected=${(e: CustomEvent) =>\n              this.onUsernameSelected(\n                Array.from(agents.entries())[e.detail.index]\n              )}\n          >\n            ${Array.from(agents.entries()).map(\n              ([pubkey, profile]) => html` <mwc-list-item\n                graphic=\"avatar\"\n                style=\"--mdc-list-item-graphic-size: 32px;\"\n              >\n                <agent-avatar\n                  slot=\"graphic\"\n                  .agentPubKey=${pubkey}\n                ></agent-avatar>\n                <span style=\"margin-left: 8px;\">${profile.nickname}</span>\n              </mwc-list-item>`\n            )}\n          </mwc-list>\n        `;\n      }\n    }\n  }\n\n  render() {\n    return html`\n      <div style=\"position: relative; flex: 1; display: flex;\">\n        <mwc-textfield\n          id=\"textfield\"\n          style=\"flex: 1;\"\n          class=\"input\"\n          .label=${this.fieldLabel ?? msg(\"Search agent\")}\n          .placeholder=${msg(\"At least 3 chars...\")}\n          outlined\n          @input=${() => this.onFilterChange()}\n        >\n        </mwc-textfield>\n        <mwc-menu-surface id=\"overlay\" absolute x=\"4\" y=\"28\"\n          >${this.renderAgentList()}</mwc-menu-surface\n        >\n      </div>\n    `;\n  }\n\n  static get styles() {\n    return [\n      sharedStyles,\n      css`\n        :host {\n          display: flex;\n        }\n        #list {\n          margin-top: 16px;\n          margin-left: 16px;\n        }\n      `,\n    ];\n  }\n\n  /**\n   * @ignore\n   */\n  static get scopedElements() {\n    return {\n      \"sl-skeleton\": SlSkeleton,\n      \"agent-avatar\": AgentAvatar,\n      \"mwc-textfield\": TextField,\n      \"mwc-menu-surface\": MenuSurface,\n      \"mwc-list\": List,\n      \"mwc-list-item\": ListItem,\n    };\n  }\n}\n","import { html, LitElement } from \"lit\";\nimport { state } from \"lit/decorators.js\";\nimport { consume } from \"@lit-labs/context\";\nimport { ScopedElementsMixin } from \"@open-wc/scoped-elements\";\nimport { Card, CircularProgress } from \"@scoped-elements/material-web\";\nimport { localized, msg } from \"@lit/localize\";\nimport { StoreSubscriber } from \"lit-svelte-stores\";\n\nimport { sharedStyles } from \"./utils/shared-styles\";\nimport { ProfilesStore } from \"../profiles-store\";\nimport { profilesStoreContext } from \"../context\";\nimport { EditProfile } from \"./edit-profile\";\nimport { Profile } from \"../types\";\n\n/**\n * @element update-profile\n * @fires profile-updated - Fired after the profile has been created. Detail will have this shape: { profile: { nickname, fields } }\n */\n@localized()\nexport class UpdateProfile extends ScopedElementsMixin(LitElement) {\n  /**\n   * @internal\n   */\n  @consume({ context: profilesStoreContext, subscribe: true })\n  @state()\n  _store!: ProfilesStore;\n\n  /** Private properties */\n\n  /**\n   * @internal\n   */\n  private _myProfile = new StoreSubscriber(this, () => this._store.myProfile);\n\n  async updateProfile(profile: Profile) {\n    await this._store.client.updateProfile(profile);\n\n    this.dispatchEvent(\n      new CustomEvent(\"profile-updated\", {\n        detail: {\n          profile,\n        },\n        bubbles: true,\n        composed: true,\n      })\n    );\n  }\n\n  render() {\n    switch (this._myProfile.value.status) {\n      case \"pending\":\n        return html`<div\n          class=\"column\"\n          style=\"align-items: center; justify-content: center; flex: 1;\"\n        >\n          <mwc-circular-progress indeterminate></mwc-circular-progress>\n        </div>`;\n      case \"complete\":\n        return html` <edit-profile\n          allowCancel\n          .profile=${this._myProfile.value.value}\n          .save-profile-label=${msg(\"Update Profile\")}\n          @save-profile=${(e: CustomEvent) =>\n            this.updateProfile(e.detail.profile)}\n        ></edit-profile>`;\n      case \"error\":\n        return html`<span\n          >${msg(\"There was an error while loading your profile\")}</span\n        >`;\n    }\n  }\n\n  /**\n   * @ignore\n   */\n  static get scopedElements() {\n    return {\n      \"mwc-circular-progress\": CircularProgress,\n      \"edit-profile\": EditProfile,\n      \"mwc-card\": Card,\n    };\n  }\n  static get styles() {\n    return [sharedStyles];\n  }\n}\n"],"names":[],"sourceRoot":""}